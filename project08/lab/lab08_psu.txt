 FUNCTION find_sorted_subarray(array, start_index)                                   # O(n)
     current_index = start_index                                                     # O(1)
     
     WHILE current_index < (length(array) - 1) AND array[current_index] <= array[current_index + 1]
         current_index += 1                                                          # O(n)  
     RETURN current_index + 1                                                        # O(1)
 
 FUNCTION merge_sorted_subarrays(sourceArray, start_index, end_of_subarray01, end_of_subarray02, destination) # O(n)
     current_index_in_sub01 = start_index                                            # O(1)
     current_index_in_sub02 = end_of_subarray01                                      # O(1)
     destination_index = start_index                                                 # O(1)
 
     WHILE current_index_in_sub01 < end_of_subarray01 AND current_index_in_sub02 < end_of_subarray02
         IF sourceArray[current_index_in_sub01] <= sourceArray[current_index_in_sub02]
             destination[destination_index] = sourceArray[current_index_in_sub01]    # O(1)
             current_index_in_sub01 += 1                                             # O(1)
         ELSE
             destination[destination_index] = sourceArray[current_index_in_sub02]    # O(1)
             current_index_in_sub02 += 1                                             # O(1)
         
         destination_index += 1                                                      # O(1)
     
     WHILE current_index_in_sub01 < end_of_subarray01
         destination[destination_index] = sourceArray[current_index_in_sub01]        # O(n)
         current_index_in_sub01 += 1                                                 # O(1)
         destination_index += 1                                                      # O(1)
       
     WHILE current_index_in_sub02 < end_of_subarray02 
         destination[destination_index] = sourceArray[current_index_in_sub02]        # O(n)
         current_index_in_sub02 += 1                                                 # O(1)
         destination_index += 1                                                      # O(1)

 FUNCTION sublist_sort(array)                                                        # O(log n)
     temp_array = Array equal to the size of the original array                      # O(1)
     array_size = length(array)                                                      # O(1)
     is_sorted = FALSE                                                               # O(1)
 
     WHILE NOT is_sorted
         is_sorted = TRUE                                                            # O(1)
         start_index = 0                                                             # O(1)
 
         WHILE start_index < array_size
             end_of_subarray01 = find_sorted_subarray(array, start_index)            # O(n)
             end_of_subarray02 = find_sorted_subarray(array, end_of_subarray01)      # O(n)
 
             IF end_of_subarray02 > array_size
                 end_of_subarray02 = array_size                                      # O(1)
             
             merge_sorted_subarrays(array, start_index, end_of_subarray01, end_of_subarray02, temp_array) # O(n)
             IF end_of_subarray02 != array_size
                 is_sorted = FALSE                                                   # O(1)
             start_index = end_of_subarray02                                         # O(1)
         SWAP array with temp_array                                                  # O(n)
     RETURN array                                                                    # O(1)
 

FUNCTION run_test_cases()
    # Define a set of test cases with input arrays and their expected sorted outputs
    test_cases = [
        { "input": [3, 2, 1, 5, 4], "expected": [1, 2, 3, 4, 5] },
        { "input": [1, 2, 3, 4, 5], "expected": [1, 2, 3, 4, 5] },  # Already sorted
        { "input": [5, 4, 3, 2, 1], "expected": [1, 2, 3, 4, 5] },  # Reverse sorted
        { "input": [1], "expected": [1] },                           # Single element
        { "input": [], "expected": [] },                             # Empty array
        { "input": [2, 2, 2, 2, 2], "expected": [2, 2, 2, 2, 2] },  # All elements the same
        { "input": ["witch", "pumpkin", "ghost", "vampire", "zombie"], "expected": ["ghost", "pumpkin", "vampire", "witch", "zombie"] }
    ]

    FOR test_case IN test_cases
        # Sort the input array using the sublist_sort function
        sorted_array = sublist_sort(test_case["input"])

        # Check if the sorted_array matches the expected output
        IF sorted_array == test_case["expected"]
            PUT "Test passed for input: ", test_case["input"]
        ELSE
            PUT "Test failed for input: ", test_case["input"]
            PUT "Expected: ", test_case["expected"], " but got: ", sorted_array



Over all efficeny = O(n log n)
Most of the program runs O(n)
The sort function is O(log n)
The Find subarray function is O(n) becasue the worse case would require each element has to be visited each loop
The merge is O(n) for the same reason it has to visit each element