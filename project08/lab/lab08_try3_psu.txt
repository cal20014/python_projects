 FUNCTION find_sorted_subarray(array, start_index)                                      # O(n)
     current_index = start_index                                                        # O(1)
     
     WHILE current_index < (length(array) - 1) AND array[current_index] <= array[current_index + 1] # O(n)
         current_index += 1                                                             # O(n)  
     RETURN current_index + 1                                                           # O(1)
 
 FUNCTION merge_sorted_subarrays(sourceArray, start_index, end_of_subarray01, end_of_subarray02, destination) # O(n)
     current_index_in_sub01 = start_index                                               # O(1)
     current_index_in_sub02 = end_of_subarray01                                         # O(1)
     destination_index = start_index                                                    # O(1)
 
     WHILE current_index_in_sub01 < end_of_subarray01 AND current_index_in_sub02 < end_of_subarray02  # O(n)
         IF sourceArray[current_index_in_sub01] <= sourceArray[current_index_in_sub02]  # O(n)
             destination[destination_index] = sourceArray[current_index_in_sub01]       # O(n)
             current_index_in_sub01 += 1                                                # O(n)
         ELSE
             destination[destination_index] = sourceArray[current_index_in_sub02]       # O(n)
             current_index_in_sub02 += 1                                                # O(n)
         
         destination_index += 1                                                         # O(n)
     
     WHILE current_index_in_sub01 < end_of_subarray01                                   # O(n)
         destination[destination_index] = sourceArray[current_index_in_sub01]           # O(n)
         current_index_in_sub01 += 1                                                    # O(n)
         destination_index += 1                                                         # O(n)
       
     WHILE current_index_in_sub02 < end_of_subarray02                                   # O(n)
         destination[destination_index] = sourceArray[current_index_in_sub02]           # O(n) 
         current_index_in_sub02 += 1                                                    # O(n)
         destination_index += 1                                                         # O(n)

 FUNCTION sublist_sort(array)                                                           # O(1)
     temp_array = Array equal to the size of the original array                         # O(1)
     array_size = length(array)                                                         # O(1)
     is_sorted = FALSE                                                                  # O(1)
 
     WHILE NOT is_sorted                                                                # O(log n)
         is_sorted = TRUE                                                               # O(log n)
         start_index = 0                                                                # O(log n)
 
         WHILE start_index < array_size                                                 # O(n log n)
             end_of_subarray01 = find_sorted_subarray(array, start_index)               # O(n log n)
             end_of_subarray02 = find_sorted_subarray(array, end_of_subarray01)         # O(n log n)
 
             IF end_of_subarray02 > array_size
                 end_of_subarray02 = array_size                                         # O(n log n)
             
             merge_sorted_subarrays(array, start_index, end_of_subarray01, end_of_subarray02, temp_array) # O(n log n)
             IF end_of_subarray02 != array_size
                 is_sorted = FALSE                                                      # O(n log n)
             start_index = end_of_subarray02                                            # O(n log n)
         SWAP array with temp_array                                                     # O(n log n)
     RETURN array                                                                       # O(n log n)
 

FUNCTION run_test_cases()
    # Test cases an array of arrays input and expected output
    test_inputs = [
        [6, 12, 11]                                             # Trace example Unsorted (required)
        [3, 2, 1, 5, 4],                                        # Normal Unsorted (required)
        [1, 2, 3, 4, 5],                                        # Already Sorted (required)
        [5, 4, 3, 2, 1],                                        # Reverse Sorted (required)
        [1],                                                    # Single Element (boundary)
        [],                                                     # Empty list (error)
        [42, 33],                                               # Empty Array (boundary)
        [2, 2, 2, 2, 2],                                        # All elements the same (error)
        [3, "apple", 2, "banana"],                              # Mixed values(error)
        ["witch", "pumpkin", "ghost", "vampire", "zombie"]      # Array of Strings Unsorted (required)
        [7, 91, 80, 56, 84, 32, 64, 88, 74, 79, 67, 1, 70, 75, 33, 17, 30, 8, 50, 71], # Large list (boundary)
    ]

    expected_outputs = [
        [1, 2, 3, 4, 5],                                
        [1, 2, 3, 4, 5],                        
        [1, 2, 3, 4, 5],                        
        [1],                        
        [],                     
        [33, 42],                       
        [2, 2, 2, 2, 2],                        
        [3, "apple", 2, "banana"],
        ["ghost", "pumpkin", "vampire", "witch", "zombie"],
        [1, 7, 8, 17, 30, 32, 33, 50, 56, 64, 67, 70, 71, 74, 75, 79, 80, 84, 88, 91],
    ]

    # Loop through each test case using its index
    FOR i from 0 to length(test_inputs) - 1
        # Sort the input array using the sublist_sort function
        sorted_array = sublist_sort(test_inputs[index])

        # Assert that the sorted_array matches the expected output
        ASSERT sorted_array == expected_outputs[index] # "Test failed for input: " + test_inputs[i]

        # If the assert does not fail, display a success message
        PUT "Test passed for input: ", test_inputs[index]



Over all efficeny = O(n log n)
Most of the program runs O(n)
The sort function is O(log n)
The Find subarray function is O(n) becasue the worse case would require each element has to be visited each loop
The merge is O(n) for the same reason it has to visit each element
